//
// auto-generated by op_seq_gen.m on 10-Mar-2011 10:07:05
//

//
// headers
//

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include "op_datatypes.h"

//
// templates
//

template < class T, class D >
void arg_check(op_set set, int m, const char *name, D *arg, int idx, op_map map,
               int dim, const char *typ, op_access acc, typename T::type *p_arg, int *ninds){
  if (idx != OP_NONE) {
    printf("error: arg %d in kernel \"%s\"\n",m,name);
    printf("invalid index, should be OP_NONE for constant arg\n");
    exit(1);
  }
  if (type_error(arg,typ)) {
    printf("error: arg %d in kernel \"%s\"\n",m,name);
    printf("data type does not match type of input dataset\n");
    exit(1);
  }
  if (type_error(p_arg,typ)) {
    printf("error: arg %d in kernel \"%s\"\n",m,name);
    printf("data type does not match type of function argument\n");
    exit(1);
  }
  if (dim <= 0) {
    printf("error: arg %d in kernel \"%s\"\n",m,name);
    printf("dimension must be strictly positive\n");
    exit(1);
  }
}

template < class T >
void arg_check(op_set set, int m, const char *name, op_dat arg, int idx, op_map map,
               int dim, const char *typ, op_access acc, typename T::type *p_arg, int *ninds){
  if (idx>=0 || idx==OP_ALL) (*ninds)++;

  if (map.map == NULL) {
    if (idx != OP_NONE) {
      printf("error: arg %d in kernel \"%s\"\n",m,name);
      printf("invalid index, should be OP_NONE for identity mapping\n");
      exit(1);
    }
  }
  else {
    if (set.index != map.from.index || arg.set.index != map.to.index) {
      printf("error: arg %d in kernel \"%s\"\n",m,name);
      printf("invalid pointer\n");
      exit(1);
    }
    if (idx != OP_ALL && (idx < 0 || idx >= map.dim)) {
      printf("error: arg %d in kernel \"%s\"\n",m,name);
      printf("invalid pointer index\n");
      exit(1);
    }
  }
  if (strcmp(arg.type,typ)) {
    printf("error: arg %d in kernel \"%s\"\n",m,name);
    printf("data type does not match type of input dataset\n");
    exit(1);
  }
  if (type_error(p_arg,typ)) {
    printf("error: arg %d in kernel \"%s\"\n",m,name);
    printf("data type does not match type of function argument\n");
    exit(1);
  }
  if (arg.dim != dim) {
    printf("error: arg %d in kernel \"%s\"\n",m,name);
    printf("dimension does not match input dataset\n");
    exit(1);
  }
}

template < typename T >
void allocate_mem(const op_map& map, const T* dat, char** p) {}

void allocate_mem(const op_map& map, const op_dat& arg, char** p) {
  *p = (char*) malloc(map.dim * arg.size);
}

template < class D >
inline void arg_set(int n,D *arg,int idx,op_map map,int dim,
             const char *typ,op_access acc,char **p_arg){
  *p_arg = (char *) arg;
}

inline void arg_set(int n,op_dat arg,int idx,op_map map,int dim,
             const char *typ,op_access acc,char **p_arg){
  int n2;
  if (map.dim==0)                   // identity mapping
    n2 = n;
  else                              // standard pointers
    n2 = map.map[idx+n*map.dim];

  *p_arg = arg.dat + n2*arg.size;
}

inline void copy_in(int n,op_dat arg,op_map map,int dim, char *p_arg){
  // For each index in the target dimension of map, copy the chunk of data for
  // the current element
  for (int i = 0; i < map.dim; ++i) {
      memcpy(p_arg+i*arg.size, arg.dat + map.map[i+n*map.dim]*arg.size, arg.size);
  }
}

template < typename T >
inline void copy_in(int n,T* arg,op_map map,int dim, char *p_arg){}

inline void copy_out(int n,op_dat arg,op_map map,int dim, char *p_arg){
  // For each index in the target dimension of map, copy the chunk of data for
  // the current element
  for (int i = 0; i < map.dim; ++i) {
      memcpy(arg.dat + map.map[i+n*map.dim]*arg.size, p_arg+i*arg.size, arg.size);
  }
}

template < typename T >
inline void copy_out(int n,T* arg,op_map map,int dim, char *p_arg){}


//
// op_par_loop routine for 1 arguments
//

template < class T0,
           class D0 >
void op_par_loop (void (*kernel)( T0 ),
  char const * name, op_set set,
  D0  arg0 ,int idx0 ,op_map map0 ,int dim0 ,const char *typ0 ,op_access acc0 ){

  char *p_arg0;

  int ninds=0;

  // consistency checks

  if (OP_diags>0) {
    arg_check<T0 >(set,0 ,name,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,(typename T0 ::type *)p_arg0 ,&ninds);
  }

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s \n",name);
    else
      printf(" kernel routine with indirection: %s \n",name);
  }

  // Allocate space for copy-in
  if (idx0  == OP_ALL) allocate_mem(map0 , arg0 , &p_arg0 );

  // loop over set elements

  for (int n=0; n<set.size; n++) {
    if (idx0  == OP_ALL) {
      if (acc0  == OP_READ || acc0  == OP_RW || acc0  == OP_INC)
        copy_in(n, arg0 , map0 , dim0 , p_arg0 );
    } else {
      arg_set(n,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,&p_arg0 );
    }

    // call kernel function, passing in pointers to data

    kernel( T0(p_arg0) );
    if (idx0  == OP_ALL)
      if (acc0  == OP_WRITE || acc0  == OP_RW || acc0  == OP_INC)
        copy_out(n, arg0 , map0 , dim0 , p_arg0 );
  }

  // Free space for copy-in
  if (idx0  == OP_ALL) free(p_arg0 );
}

//
// op_par_loop routine for 2 arguments
//

template < class T0, class T1,
           class D0, class D1 >
void op_par_loop (void (*kernel)( T0, T1 ),
  char const * name, op_set set,
  D0  arg0 ,int idx0 ,op_map map0 ,int dim0 ,const char *typ0 ,op_access acc0 ,
  D1  arg1 ,int idx1 ,op_map map1 ,int dim1 ,const char *typ1 ,op_access acc1 ){

  char *p_arg0, *p_arg1;

  int ninds=0;

  // consistency checks

  if (OP_diags>0) {
    arg_check<T0 >(set,0 ,name,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,(typename T0 ::type *)p_arg0 ,&ninds);
    arg_check<T1 >(set,1 ,name,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,(typename T1 ::type *)p_arg1 ,&ninds);
  }

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s \n",name);
    else
      printf(" kernel routine with indirection: %s \n",name);
  }

  // Allocate space for copy-in
  if (idx0  == OP_ALL) allocate_mem(map0 , arg0 , &p_arg0 );
  if (idx1  == OP_ALL) allocate_mem(map1 , arg1 , &p_arg1 );

  // loop over set elements

  for (int n=0; n<set.size; n++) {
    if (idx0  == OP_ALL) {
      if (acc0  == OP_READ || acc0  == OP_RW || acc0  == OP_INC)
        copy_in(n, arg0 , map0 , dim0 , p_arg0 );
    } else {
      arg_set(n,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,&p_arg0 );
    }
    if (idx1  == OP_ALL) {
      if (acc1  == OP_READ || acc1  == OP_RW || acc1  == OP_INC)
        copy_in(n, arg1 , map1 , dim1 , p_arg1 );
    } else {
      arg_set(n,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,&p_arg1 );
    }

    // call kernel function, passing in pointers to data

    kernel( T0(p_arg0),  T1(p_arg1) );
    if (idx0  == OP_ALL)
      if (acc0  == OP_WRITE || acc0  == OP_RW || acc0  == OP_INC)
        copy_out(n, arg0 , map0 , dim0 , p_arg0 );
    if (idx1  == OP_ALL)
      if (acc1  == OP_WRITE || acc1  == OP_RW || acc1  == OP_INC)
        copy_out(n, arg1 , map1 , dim1 , p_arg1 );
  }

  // Free space for copy-in
  if (idx0  == OP_ALL) free(p_arg0 );
  if (idx1  == OP_ALL) free(p_arg1 );
}

//
// op_par_loop routine for 3 arguments
//

template < class T0, class T1, class T2,
           class D0, class D1, class D2 >
void op_par_loop (void (*kernel)( T0, T1, T2 ),
  char const * name, op_set set,
  D0  arg0 ,int idx0 ,op_map map0 ,int dim0 ,const char *typ0 ,op_access acc0 ,
  D1  arg1 ,int idx1 ,op_map map1 ,int dim1 ,const char *typ1 ,op_access acc1 ,
  D2  arg2 ,int idx2 ,op_map map2 ,int dim2 ,const char *typ2 ,op_access acc2 ){

  char *p_arg0, *p_arg1, *p_arg2;

  int ninds=0;

  // consistency checks

  if (OP_diags>0) {
    arg_check<T0 >(set,0 ,name,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,(typename T0 ::type *)p_arg0 ,&ninds);
    arg_check<T1 >(set,1 ,name,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,(typename T1 ::type *)p_arg1 ,&ninds);
    arg_check<T2 >(set,2 ,name,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,(typename T2 ::type *)p_arg2 ,&ninds);
  }

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s \n",name);
    else
      printf(" kernel routine with indirection: %s \n",name);
  }

  // Allocate space for copy-in
  if (idx0  == OP_ALL) allocate_mem(map0 , arg0 , &p_arg0 );
  if (idx1  == OP_ALL) allocate_mem(map1 , arg1 , &p_arg1 );
  if (idx2  == OP_ALL) allocate_mem(map2 , arg2 , &p_arg2 );

  // loop over set elements

  for (int n=0; n<set.size; n++) {
    if (idx0  == OP_ALL) {
      if (acc0  == OP_READ || acc0  == OP_RW || acc0  == OP_INC)
        copy_in(n, arg0 , map0 , dim0 , p_arg0 );
    } else {
      arg_set(n,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,&p_arg0 );
    }
    if (idx1  == OP_ALL) {
      if (acc1  == OP_READ || acc1  == OP_RW || acc1  == OP_INC)
        copy_in(n, arg1 , map1 , dim1 , p_arg1 );
    } else {
      arg_set(n,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,&p_arg1 );
    }
    if (idx2  == OP_ALL) {
      if (acc2  == OP_READ || acc2  == OP_RW || acc2  == OP_INC)
        copy_in(n, arg2 , map2 , dim2 , p_arg2 );
    } else {
      arg_set(n,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,&p_arg2 );
    }

    // call kernel function, passing in pointers to data

    kernel( T0(p_arg0),  T1(p_arg1),  T2(p_arg2) );
    if (idx0  == OP_ALL)
      if (acc0  == OP_WRITE || acc0  == OP_RW || acc0  == OP_INC)
        copy_out(n, arg0 , map0 , dim0 , p_arg0 );
    if (idx1  == OP_ALL)
      if (acc1  == OP_WRITE || acc1  == OP_RW || acc1  == OP_INC)
        copy_out(n, arg1 , map1 , dim1 , p_arg1 );
    if (idx2  == OP_ALL)
      if (acc2  == OP_WRITE || acc2  == OP_RW || acc2  == OP_INC)
        copy_out(n, arg2 , map2 , dim2 , p_arg2 );
  }

  // Free space for copy-in
  if (idx0  == OP_ALL) free(p_arg0 );
  if (idx1  == OP_ALL) free(p_arg1 );
  if (idx2  == OP_ALL) free(p_arg2 );
}

//
// op_par_loop routine for 4 arguments
//

template < class T0, class T1, class T2, class T3,
           class D0, class D1, class D2, class D3 >
void op_par_loop (void (*kernel)( T0, T1, T2, T3 ),
  char const * name, op_set set,
  D0  arg0 ,int idx0 ,op_map map0 ,int dim0 ,const char *typ0 ,op_access acc0 ,
  D1  arg1 ,int idx1 ,op_map map1 ,int dim1 ,const char *typ1 ,op_access acc1 ,
  D2  arg2 ,int idx2 ,op_map map2 ,int dim2 ,const char *typ2 ,op_access acc2 ,
  D3  arg3 ,int idx3 ,op_map map3 ,int dim3 ,const char *typ3 ,op_access acc3 ){

  char *p_arg0, *p_arg1, *p_arg2, *p_arg3;

  int ninds=0;

  // consistency checks

  if (OP_diags>0) {
    arg_check<T0 >(set,0 ,name,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,(typename T0 ::type *)p_arg0 ,&ninds);
    arg_check<T1 >(set,1 ,name,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,(typename T1 ::type *)p_arg1 ,&ninds);
    arg_check<T2 >(set,2 ,name,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,(typename T2 ::type *)p_arg2 ,&ninds);
    arg_check<T3 >(set,3 ,name,arg3 ,idx3 ,map3 ,dim3 ,typ3 ,acc3 ,(typename T3 ::type *)p_arg3 ,&ninds);
  }

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s \n",name);
    else
      printf(" kernel routine with indirection: %s \n",name);
  }

  // Allocate space for copy-in
  if (idx0  == OP_ALL) allocate_mem(map0 , arg0 , &p_arg0 );
  if (idx1  == OP_ALL) allocate_mem(map1 , arg1 , &p_arg1 );
  if (idx2  == OP_ALL) allocate_mem(map2 , arg2 , &p_arg2 );
  if (idx3  == OP_ALL) allocate_mem(map3 , arg3 , &p_arg3 );

  // loop over set elements

  for (int n=0; n<set.size; n++) {
    if (idx0  == OP_ALL) {
      if (acc0  == OP_READ || acc0  == OP_RW || acc0  == OP_INC)
        copy_in(n, arg0 , map0 , dim0 , p_arg0 );
    } else {
      arg_set(n,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,&p_arg0 );
    }
    if (idx1  == OP_ALL) {
      if (acc1  == OP_READ || acc1  == OP_RW || acc1  == OP_INC)
        copy_in(n, arg1 , map1 , dim1 , p_arg1 );
    } else {
      arg_set(n,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,&p_arg1 );
    }
    if (idx2  == OP_ALL) {
      if (acc2  == OP_READ || acc2  == OP_RW || acc2  == OP_INC)
        copy_in(n, arg2 , map2 , dim2 , p_arg2 );
    } else {
      arg_set(n,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,&p_arg2 );
    }
    if (idx3  == OP_ALL) {
      if (acc3  == OP_READ || acc3  == OP_RW || acc3  == OP_INC)
        copy_in(n, arg3 , map3 , dim3 , p_arg3 );
    } else {
      arg_set(n,arg3 ,idx3 ,map3 ,dim3 ,typ3 ,acc3 ,&p_arg3 );
    }

    // call kernel function, passing in pointers to data

    kernel( T0(p_arg0),  T1(p_arg1),  T2(p_arg2),  T3(p_arg3) );
    if (idx0  == OP_ALL)
      if (acc0  == OP_WRITE || acc0  == OP_RW || acc0  == OP_INC)
        copy_out(n, arg0 , map0 , dim0 , p_arg0 );
    if (idx1  == OP_ALL)
      if (acc1  == OP_WRITE || acc1  == OP_RW || acc1  == OP_INC)
        copy_out(n, arg1 , map1 , dim1 , p_arg1 );
    if (idx2  == OP_ALL)
      if (acc2  == OP_WRITE || acc2  == OP_RW || acc2  == OP_INC)
        copy_out(n, arg2 , map2 , dim2 , p_arg2 );
    if (idx3  == OP_ALL)
      if (acc3  == OP_WRITE || acc3  == OP_RW || acc3  == OP_INC)
        copy_out(n, arg3 , map3 , dim3 , p_arg3 );
  }

  // Free space for copy-in
  if (idx0  == OP_ALL) free(p_arg0 );
  if (idx1  == OP_ALL) free(p_arg1 );
  if (idx2  == OP_ALL) free(p_arg2 );
  if (idx3  == OP_ALL) free(p_arg3 );
}

//
// op_par_loop routine for 5 arguments
//

template < class T0, class T1, class T2, class T3, class T4,
           class D0, class D1, class D2, class D3, class D4 >
void op_par_loop (void (*kernel)( T0, T1, T2, T3, T4 ),
  char const * name, op_set set,
  D0  arg0 ,int idx0 ,op_map map0 ,int dim0 ,const char *typ0 ,op_access acc0 ,
  D1  arg1 ,int idx1 ,op_map map1 ,int dim1 ,const char *typ1 ,op_access acc1 ,
  D2  arg2 ,int idx2 ,op_map map2 ,int dim2 ,const char *typ2 ,op_access acc2 ,
  D3  arg3 ,int idx3 ,op_map map3 ,int dim3 ,const char *typ3 ,op_access acc3 ,
  D4  arg4 ,int idx4 ,op_map map4 ,int dim4 ,const char *typ4 ,op_access acc4 ){

  char *p_arg0, *p_arg1, *p_arg2, *p_arg3, *p_arg4;

  int ninds=0;

  // consistency checks

  if (OP_diags>0) {
    arg_check<T0 >(set,0 ,name,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,(typename T0 ::type *)p_arg0 ,&ninds);
    arg_check<T1 >(set,1 ,name,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,(typename T1 ::type *)p_arg1 ,&ninds);
    arg_check<T2 >(set,2 ,name,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,(typename T2 ::type *)p_arg2 ,&ninds);
    arg_check<T3 >(set,3 ,name,arg3 ,idx3 ,map3 ,dim3 ,typ3 ,acc3 ,(typename T3 ::type *)p_arg3 ,&ninds);
    arg_check<T4 >(set,4 ,name,arg4 ,idx4 ,map4 ,dim4 ,typ4 ,acc4 ,(typename T4 ::type *)p_arg4 ,&ninds);
  }

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s \n",name);
    else
      printf(" kernel routine with indirection: %s \n",name);
  }

  // Allocate space for copy-in
  if (idx0  == OP_ALL) allocate_mem(map0 , arg0 , &p_arg0 );
  if (idx1  == OP_ALL) allocate_mem(map1 , arg1 , &p_arg1 );
  if (idx2  == OP_ALL) allocate_mem(map2 , arg2 , &p_arg2 );
  if (idx3  == OP_ALL) allocate_mem(map3 , arg3 , &p_arg3 );
  if (idx4  == OP_ALL) allocate_mem(map4 , arg4 , &p_arg4 );

  // loop over set elements

  for (int n=0; n<set.size; n++) {
    if (idx0  == OP_ALL) {
      if (acc0  == OP_READ || acc0  == OP_RW || acc0  == OP_INC)
        copy_in(n, arg0 , map0 , dim0 , p_arg0 );
    } else {
      arg_set(n,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,&p_arg0 );
    }
    if (idx1  == OP_ALL) {
      if (acc1  == OP_READ || acc1  == OP_RW || acc1  == OP_INC)
        copy_in(n, arg1 , map1 , dim1 , p_arg1 );
    } else {
      arg_set(n,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,&p_arg1 );
    }
    if (idx2  == OP_ALL) {
      if (acc2  == OP_READ || acc2  == OP_RW || acc2  == OP_INC)
        copy_in(n, arg2 , map2 , dim2 , p_arg2 );
    } else {
      arg_set(n,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,&p_arg2 );
    }
    if (idx3  == OP_ALL) {
      if (acc3  == OP_READ || acc3  == OP_RW || acc3  == OP_INC)
        copy_in(n, arg3 , map3 , dim3 , p_arg3 );
    } else {
      arg_set(n,arg3 ,idx3 ,map3 ,dim3 ,typ3 ,acc3 ,&p_arg3 );
    }
    if (idx4  == OP_ALL) {
      if (acc4  == OP_READ || acc4  == OP_RW || acc4  == OP_INC)
        copy_in(n, arg4 , map4 , dim4 , p_arg4 );
    } else {
      arg_set(n,arg4 ,idx4 ,map4 ,dim4 ,typ4 ,acc4 ,&p_arg4 );
    }

    // call kernel function, passing in pointers to data

    kernel( T0(p_arg0),  T1(p_arg1),  T2(p_arg2),  T3(p_arg3),  T4(p_arg4) );
    if (idx0  == OP_ALL)
      if (acc0  == OP_WRITE || acc0  == OP_RW || acc0  == OP_INC)
        copy_out(n, arg0 , map0 , dim0 , p_arg0 );
    if (idx1  == OP_ALL)
      if (acc1  == OP_WRITE || acc1  == OP_RW || acc1  == OP_INC)
        copy_out(n, arg1 , map1 , dim1 , p_arg1 );
    if (idx2  == OP_ALL)
      if (acc2  == OP_WRITE || acc2  == OP_RW || acc2  == OP_INC)
        copy_out(n, arg2 , map2 , dim2 , p_arg2 );
    if (idx3  == OP_ALL)
      if (acc3  == OP_WRITE || acc3  == OP_RW || acc3  == OP_INC)
        copy_out(n, arg3 , map3 , dim3 , p_arg3 );
    if (idx4  == OP_ALL)
      if (acc4  == OP_WRITE || acc4  == OP_RW || acc4  == OP_INC)
        copy_out(n, arg4 , map4 , dim4 , p_arg4 );
  }

  // Free space for copy-in
  if (idx0  == OP_ALL) free(p_arg0 );
  if (idx1  == OP_ALL) free(p_arg1 );
  if (idx2  == OP_ALL) free(p_arg2 );
  if (idx3  == OP_ALL) free(p_arg3 );
  if (idx4  == OP_ALL) free(p_arg4 );
}

//
// op_par_loop routine for 6 arguments
//

template < class T0, class T1, class T2, class T3, class T4,
           class T5,
           class D0, class D1, class D2, class D3, class D4,
           class D5 >
void op_par_loop (void (*kernel)( T0, T1, T2, T3, T4,
                                    T5 ),
  char const * name, op_set set,
  D0  arg0 ,int idx0 ,op_map map0 ,int dim0 ,const char *typ0 ,op_access acc0 ,
  D1  arg1 ,int idx1 ,op_map map1 ,int dim1 ,const char *typ1 ,op_access acc1 ,
  D2  arg2 ,int idx2 ,op_map map2 ,int dim2 ,const char *typ2 ,op_access acc2 ,
  D3  arg3 ,int idx3 ,op_map map3 ,int dim3 ,const char *typ3 ,op_access acc3 ,
  D4  arg4 ,int idx4 ,op_map map4 ,int dim4 ,const char *typ4 ,op_access acc4 ,
  D5  arg5 ,int idx5 ,op_map map5 ,int dim5 ,const char *typ5 ,op_access acc5 ){

  char *p_arg0, *p_arg1, *p_arg2, *p_arg3, *p_arg4,
       *p_arg5;

  int ninds=0;

  // consistency checks

  if (OP_diags>0) {
    arg_check<T0 >(set,0 ,name,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,(typename T0 ::type *)p_arg0 ,&ninds);
    arg_check<T1 >(set,1 ,name,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,(typename T1 ::type *)p_arg1 ,&ninds);
    arg_check<T2 >(set,2 ,name,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,(typename T2 ::type *)p_arg2 ,&ninds);
    arg_check<T3 >(set,3 ,name,arg3 ,idx3 ,map3 ,dim3 ,typ3 ,acc3 ,(typename T3 ::type *)p_arg3 ,&ninds);
    arg_check<T4 >(set,4 ,name,arg4 ,idx4 ,map4 ,dim4 ,typ4 ,acc4 ,(typename T4 ::type *)p_arg4 ,&ninds);
    arg_check<T5 >(set,5 ,name,arg5 ,idx5 ,map5 ,dim5 ,typ5 ,acc5 ,(typename T5 ::type *)p_arg5 ,&ninds);
  }

  if (OP_diags>2) {
    if (ninds==0)
      printf(" kernel routine w/o indirection:  %s \n",name);
    else
      printf(" kernel routine with indirection: %s \n",name);
  }

  // Allocate space for copy-in
  if (idx0  == OP_ALL) allocate_mem(map0 , arg0 , &p_arg0 );
  if (idx1  == OP_ALL) allocate_mem(map1 , arg1 , &p_arg1 );
  if (idx2  == OP_ALL) allocate_mem(map2 , arg2 , &p_arg2 );
  if (idx3  == OP_ALL) allocate_mem(map3 , arg3 , &p_arg3 );
  if (idx4  == OP_ALL) allocate_mem(map4 , arg4 , &p_arg4 );
  if (idx5  == OP_ALL) allocate_mem(map5 , arg5 , &p_arg5 );

  // loop over set elements

  for (int n=0; n<set.size; n++) {
    if (idx0  == OP_ALL) {
      if (acc0  == OP_READ || acc0  == OP_RW || acc0  == OP_INC)
        copy_in(n, arg0 , map0 , dim0 , p_arg0 );
    } else {
      arg_set(n,arg0 ,idx0 ,map0 ,dim0 ,typ0 ,acc0 ,&p_arg0 );
    }
    if (idx1  == OP_ALL) {
      if (acc1  == OP_READ || acc1  == OP_RW || acc1  == OP_INC)
        copy_in(n, arg1 , map1 , dim1 , p_arg1 );
    } else {
      arg_set(n,arg1 ,idx1 ,map1 ,dim1 ,typ1 ,acc1 ,&p_arg1 );
    }
    if (idx2  == OP_ALL) {
      if (acc2  == OP_READ || acc2  == OP_RW || acc2  == OP_INC)
        copy_in(n, arg2 , map2 , dim2 , p_arg2 );
    } else {
      arg_set(n,arg2 ,idx2 ,map2 ,dim2 ,typ2 ,acc2 ,&p_arg2 );
    }
    if (idx3  == OP_ALL) {
      if (acc3  == OP_READ || acc3  == OP_RW || acc3  == OP_INC)
        copy_in(n, arg3 , map3 , dim3 , p_arg3 );
    } else {
      arg_set(n,arg3 ,idx3 ,map3 ,dim3 ,typ3 ,acc3 ,&p_arg3 );
    }
    if (idx4  == OP_ALL) {
      if (acc4  == OP_READ || acc4  == OP_RW || acc4  == OP_INC)
        copy_in(n, arg4 , map4 , dim4 , p_arg4 );
    } else {
      arg_set(n,arg4 ,idx4 ,map4 ,dim4 ,typ4 ,acc4 ,&p_arg4 );
    }
    if (idx5  == OP_ALL) {
      if (acc5  == OP_READ || acc5  == OP_RW || acc5  == OP_INC)
        copy_in(n, arg5 , map5 , dim5 , p_arg5 );
    } else {
      arg_set(n,arg5 ,idx5 ,map5 ,dim5 ,typ5 ,acc5 ,&p_arg5 );
    }

    // call kernel function, passing in pointers to data

    kernel( T0(p_arg0),  T1(p_arg1),  T2(p_arg2),  T3(p_arg3),  T4(p_arg4),
            T5(p_arg5) );
    if (idx0  == OP_ALL)
      if (acc0  == OP_WRITE || acc0  == OP_RW || acc0  == OP_INC)
        copy_out(n, arg0 , map0 , dim0 , p_arg0 );
    if (idx1  == OP_ALL)
      if (acc1  == OP_WRITE || acc1  == OP_RW || acc1  == OP_INC)
        copy_out(n, arg1 , map1 , dim1 , p_arg1 );
    if (idx2  == OP_ALL)
      if (acc2  == OP_WRITE || acc2  == OP_RW || acc2  == OP_INC)
        copy_out(n, arg2 , map2 , dim2 , p_arg2 );
    if (idx3  == OP_ALL)
      if (acc3  == OP_WRITE || acc3  == OP_RW || acc3  == OP_INC)
        copy_out(n, arg3 , map3 , dim3 , p_arg3 );
    if (idx4  == OP_ALL)
      if (acc4  == OP_WRITE || acc4  == OP_RW || acc4  == OP_INC)
        copy_out(n, arg4 , map4 , dim4 , p_arg4 );
    if (idx5  == OP_ALL)
      if (acc5  == OP_WRITE || acc5  == OP_RW || acc5  == OP_INC)
        copy_out(n, arg5 , map5 , dim5 , p_arg5 );
  }

  // Free space for copy-in
  if (idx0  == OP_ALL) free(p_arg0 );
  if (idx1  == OP_ALL) free(p_arg1 );
  if (idx2  == OP_ALL) free(p_arg2 );
  if (idx3  == OP_ALL) free(p_arg3 );
  if (idx4  == OP_ALL) free(p_arg4 );
  if (idx5  == OP_ALL) free(p_arg5 );
}
