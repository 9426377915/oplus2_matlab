\documentclass[12pt]{article}

\usepackage[colorlinks,urlcolor=blue]{hyperref}

\topmargin 0in
\textheight 8.25in
\textwidth  5.75in

\parskip 5pt


\begin{document}

\title{Software engineering tools\\for OP2 project}
\author{Mike Giles}


\maketitle

\begin{abstract}
As we begin phase 2 of the OP2 project, with an increased 
amount of collaboration between different developers, I think
it is a good time to consider the software engineering tools
we will use.

As an Associate Director of the Oxford e-Research Centre,
I'm also interested in this topic to identify and promote
best practice in software projects within OeRC.

This is an area in which I am aware that my own knowledge
and practice is deficient, so many of my suggestions are 
based on the recommendations of others, and I will be 
interested to hear people's opinions on them.

\end{abstract}

%\newpage

\section*{Tools}

\begin{itemize}

\item
Version control

I've been told that 
\href{http://git-scm.com/}{git}
and the web-based 
\href{http://github.com/}{GitHub}
are much better than the older
\href{http://www.nongnu.org/cvs/}{CVS} 
and
\href{http://subversion.apache.org/}{SVN}.

\item 
Make system

Currently, we use GNU makefiles, but in the future we should
consider using 
\href{http://en.wikipedia.org/wiki/CMake}{CMake}
which is platform independent and has
\href{http://rafaelpalomar.net/blog/2010/jan/22/building-cuda-projects-cmake}{CUDA support}.


\item
Compilers

Currently we are using NVIDIA's {\tt nvcc} for the CUDA code, 
and {\tt g++} for the C/C++ code, but in the future we will
be using PGI's
\href{http://www.pgroup.com/resources/cudafortran.htm}{CUDA FORTRAN}
compiler, and also ought to consider
\href{http://software.intel.com/en-us/intel-compilers/}{Intel's compilers}
for multithreaded C/C++/FORTRAN code and to produce AVX executables.


\item
MPI

There are several different MPI implementations.  We will probably
continue to use the one recommended / supplied by the hardware supplier.

For parallel file I/O, we plan to use
\href{http://www.hdfgroup.org/HDF5/PHDF5/}{Parallel HDF5}
which is 
\href{http://www.hdfgroup.org/HDF5/Tutor/poverview.html}{built on MPI-IO}, 
rather than directly using
\href{http://www.nersc.gov/nusers/resources/software/libs/io/mpiio.php}{MPI-IO}.


\item
Parallel debugging

I think Allinea's 
\href{http://www.allinea.com/?page=48}{DDT}
is the best choice for both MPI and CUDA applications. At present the 
\href{http://www.allinea.com/?page=131}{CUDA support }
is only for CUDA version 3.0, but 3.1/3.2 should be supported in the near future

%A possible alternative is 
%\href{http://www.totalviewtech.com/}{TotalView}.

\item
Performance monitoring and optimisation

I think Allinea's
\href{http://www.allinea.com/?page=74}{OPT}
may be good for MPI applications, but I don't know if it has 
any support for CUDA.

Stephen Jarvis' group models the performance of parallel 
applications using network data obtained from
\href{http://www.fz-juelich.de/jsc/scalasca/}{Scalasca}
and low-level CPU performance data from
\href{http://icl.cs.utk.edu/papi/}{PAPI}.

Another possibility for low-level optimisation of CPU code
(particularly multithreaded code?) is Intel's
\href{http://software.intel.com/en-us/intel-vtune/}{vtune}
software.


\item
Code documentation

At present, I am happy to write documentation in LaTeX, and
that allows me to write different sets of documentation for
users and developers.

However, some people recommend the use of
\href{http://sourceforge.net/projects/doxygen/}{Doxygen}
and this could be considered to generate the 
definitive developer reference.

\item
Build-and-test

I'm told that 
\href{http://buildbot.net/trac}{Buildbot} 
is the standard choice for automated compilation and testing.


\item
Coverage testing

This is something I've never used before, but tools such as
\href{http://gcc.gnu.org/onlinedocs/gcc/Gcov.html}{gcov}
and
\href{http://ltp.sourceforge.net/coverage/lcov.php}{lcov}
check which bits of your code are being exercised by the testcases 
used to validate the code.


\item
Code generation

Currently, the OP2 code generator is written in MATLAB.
This is not an ideal choice; it's simply a language I am 
comfortable with. Paul Kelly's group may re-write it 
entirely in
\href{http://www.rosecompiler.org/}{rose}
or it could be ported to python.
% which might have better 
%\href{http://nedbatchelder.com/text/python-parsers.html}{parsing support}.

\end{itemize}



\end{document}

