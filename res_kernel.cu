// 
// auto-generated by op2.m on 12-Feb-2010 12:40:37 
//

// header files                                                                   
                                                                                  
#include <stdlib.h>                                                               
#include <stdio.h>                                                                
#include <string.h>                                                               
#include <math.h>                                                                 
#include <cutil_inline.h>                                                         
#include "op_datatypes.h"                                                         
                                                                                  
                                                                                  
extern "C"                                                                        
op_plan * plan(char const *, op_set, int, op_dat *, int *,                        
  op_ptr *, int *, op_datatype *, op_access *, int, int *);                       
                                                                                  
                                                                                  
// user function                                                                  
                                                                                  
__device__                                                                        
#include "res.h"                                                                  
                                                                                  
                                                                                  
// CUDA kernel function                                                           
                                                                                  
__global__ void op_cuda_res(                                                      
  float  *ind_arg0, int *ind_arg0_ptr, int *ind_arg0_sizes, int *ind_arg0_offset, 
  float  *ind_arg1, int *ind_arg1_ptr, int *ind_arg1_sizes, int *ind_arg1_offset, 
  double *arg0,                                                                   
  int   *arg1_ptr,                                                                
  int   *arg2_ptr,                                                                
  int    block_offset,                                                            
  int   *blkmap,                                                                  
  int   *offset,                                                                  
  int   *nelems,                                                                  
  int   *ncolors,                                                                 
  int   *colors) {                                                                
                                                                                  
  float  *ind_arg0_s;                                                             
  float  *ind_arg1_s;                                                             
  double  arg0_l[1];                                                              
  float   arg1_l[1];                                                              
  float   arg2_l[1];                                                              
                                                                                  
  extern __shared__ int shared[];                                                 
                                                                                  
  // get block info                                                               
                                                                                  
  int blockId = blkmap[blockIdx.x + block_offset];                                
                                                                                  
  // get sizes and shift pointers and direct-mapped data                          
                                                                                  
  int ind_arg0_size = ind_arg0_sizes[blockId];                                    
  int ind_arg1_size = ind_arg1_sizes[blockId];                                    
                                                                                  
  ind_arg0_ptr += ind_arg0_offset[blockId];                                       
  ind_arg1_ptr += ind_arg1_offset[blockId];                                       
                                                                                  
  arg0         += offset[blockId]*1;                                              
  arg1_ptr     += offset[blockId];                                                
  arg2_ptr     += offset[blockId];                                                
  colors       += offset[blockId];                                                
                                                                                  
  // set shared memory pointers                                                   
                                                                                  
  ind_arg0_s = (float  *) shared;                                                 
  ind_arg1_s = (float  *) &ind_arg0_s[ind_arg0_size*1];                           
                                                                                  
  // copy indirect datasets into shared memory or zero increment                  
                                                                                  
  for (int n=threadIdx.x; n<ind_arg0_size; n+=blockDim.x)                         
    for (int d=0; d<1; d++)                                                       
      ind_arg0_s[d+n*1] = ind_arg0[d+ind_arg0_ptr[n]*1];                          
                                                                                  
  for (int n=threadIdx.x; n<ind_arg1_size; n+=blockDim.x)                         
    for (int d=0; d<1; d++)                                                       
      ind_arg1_s[d+n*1] = 0;                                                      
                                                                                  
  __syncthreads();                                                                
                                                                                  
  // process set elements                                                         
                                                                                  
  int nelems2 = blockDim.x*(1+(nelems[blockId]-1)/blockDim.x);                    
                                                                                  
  for (int n=threadIdx.x; n<nelems2; n+=blockDim.x) {                             
    int col2 = ncolors[blockId];                                                  
                                                                                  
    if (n<nelems[blockId]) {                                                      
                                                                                  
      // initialise local variables                                               
                                                                                  
      for (int d=0; d<1; d++)                                                     
        arg0_l[d] = arg0[d+n*1];                                                  
      for (int d=0; d<1; d++)                                                     
        arg1_l[d] = ind_arg0_s[d+arg1_ptr[n]*1];                                  
      for (int d=0; d<1; d++)                                                     
        arg2_l[d] = 0;                                                            
                                                                                  
      // user-supplied kernel call                                                
                                                                                  
      res(arg0_l,arg1_l,arg2_l);                                                  
                                                                                  
       col2 = colors[n];                                                          
                                                                                  
    }                                                                             
                                                                                  
    // store local variables                                                      
                                                                                  
    for (int col=0; col<ncolors[blockId]; col++) {                                
      if (col2==col)                                                              
        for (int d=0; d<1; d++)                                                   
          ind_arg1_s[d+arg2_ptr[n]*1] += arg2_l[d];                               
      __syncthreads();                                                            
    }                                                                             
                                                                                  
  }                                                                               
                                                                                  
  // apply pointered write/increment                                              
                                                                                  
  for (int n=threadIdx.x; n<ind_arg1_size; n+=blockDim.x)                         
    for (int d=0; d<1; d++)                                                       
      ind_arg1[d+ind_arg1_ptr[n]*1] += ind_arg1_s[d+n*1];                         
                                                                                  
}                                                                                 
                                                                                  
                                                                                  
// host stub function                                                             
                                                                                  
extern "C"                                                                        
void op_par_loop_res(char const * name, op_set set,                               
  op_dat arg0, int idx0, op_ptr ptr0, int dim0, op_datatype typ0, op_access acc0, 
  op_dat arg1, int idx1, op_ptr ptr1, int dim1, op_datatype typ1, op_access acc1, 
  op_dat arg2, int idx2, op_ptr ptr2, int dim2, op_datatype typ2, op_access acc2){
                                                                                  
  int         nargs = 3, ninds = 2;                                               
                                                                                  
  op_dat      args[3] = {arg0,arg1,arg2};                                         
  int         idxs[3] = {idx0,idx1,idx2};                                         
  op_ptr      ptrs[3] = {ptr0,ptr1,ptr2};                                         
  int         dims[3] = {dim0,dim1,dim2};                                         
  op_datatype typs[3] = {typ0,typ1,typ2};                                         
  op_access   accs[3] = {acc0,acc1,acc2};                                         
  int         inds[3] = {-1,0,1};                                                 
                                                                                  
  if (OP_DIAGS>1) {                                                               
    printf(" kernel routine with indirection: res \n");                           
  }                                                                               
                                                                                  
  // get plan                                                                     
                                                                                  
  op_plan *Plan = plan(name,set,nargs,args,idxs,ptrs,dims,typs,accs,ninds,inds);  
                                                                                  
  // execute plan                                                                 
                                                                                  
  int block_offset = 0;                                                           
                                                                                  
  float  *ind_arg0 = arg1.fdat_d;                                                 
  float  *ind_arg1 = arg2.fdat_d;                                                 
                                                                                  
  for (int col=0; col<(*Plan).ncolors; col++) {                                   
                                                                                  
    int nblocks = (*Plan).ncolblk[col];                                           
    int nshared = (*Plan).nshared;                                                
                                                                                  
    op_cuda_res<<<nblocks,64,nshared>>>(                                          
        ind_arg0, (*Plan).ind_ptrs[0], (*Plan).ind_sizes[0], (*Plan).ind_offs[0], 
        ind_arg1, (*Plan).ind_ptrs[1], (*Plan).ind_sizes[1], (*Plan).ind_offs[1], 
        arg0.ddat_d,                                                              
        (*Plan).ptrs[1],                                                          
        (*Plan).ptrs[2],                                                          
        block_offset,                                                             
        (*Plan).blkmap,                                                           
        (*Plan).offset,                                                           
        (*Plan).nelems,                                                           
        (*Plan).nthrcol,                                                          
        (*Plan).thrcol);                                                          
                                                                                  
    cutilSafeCall(cudaThreadSynchronize());                                       
    cutilCheckMsg("op_cuda_res execution failed\n");                              
                                                                                  
    block_offset += nblocks;                                                      
  }                                                                               
}                                                                                 
