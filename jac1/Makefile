#
# set paths for header files and libraries
#

OP2		:= ../common
CUDA		:= $(CUDA_INSTALL_PATH)
INC		:= -I$(CUDA)/include -I$(OP2) -I.
LIB		:= -L$(CUDA)/lib64
CC		:= icc

MPI_HOME	:=/home/gihan/openmpi
MPICC		:=$(MPI_HOME)/bin/mpiCC 

#
# set flags for compilation and linking
#

CCFLAGS		:= -O3 -ipo -vec-report -xSSE2,SSE3,SSSE3,SSE4.1,SSE4.2 -funroll-loops -DDEBUG -Wall -Wextra #-g
NVCCFLAGS	:= -g -G -arch=sm_20 -Xptxas=-v -use_fast_math
LIBS		:= $(LIB) -lcudart
OMP		:= -openmp 

#
# master to make all versions
#

all:		jac_seq jac_op jac_cuda jac_mpi

#
# simple sequential version
#

jac_seq:	jac.cpp $(OP2)/op_seq.cpp $(OP2)/op_datatypes.h
		$(CC) $(CCFLAGS) $(INC) -o jac_seq jac.cpp $(OP2)/op_seq.cpp

#
# x86 version using kernel files generated by op2.m
#

jac_op:		jac_op.cpp jac_kernels.cpp $(OP2)/op_datatypes.h \
                $(OP2)/op_lib.cu $(OP2)/op_lib.cpp \
		res_kernel.cpp update_kernel.cpp \
		res.h update.h
		$(CC) $(CCFLAGS) $(INC) $(OMP) -o jac_op jac_op.cpp jac_kernels.cpp

#
# CUDA version using kernel files generated by op2.m
#

jac_cuda:	jac_op.o jac_kernels.o
		$(CC) $(CCFLAGS) -fPIC -o jac_cuda jac_op.o jac_kernels.o $(LIBS)

jac_op.o:	jac_op.cpp $(OP2)/op_datatypes.h Makefile
		$(CC) $(CCFLAGS) $(INC) $(CCFLAGS) -c -o jac_op.o jac_op.cpp

jac_kernels.o:	jac_kernels.cu $(OP2)/op_lib.cu \
                $(OP2)/op_datatypes.h  Makefile \
		res_kernel.cu update_kernel.cu  \
		res.h update.h
		nvcc $(INC) $(NVCCFLAGS) -c -o jac_kernels.o jac_kernels.cu

#
# MPI version using op2 sequential code
#

jac_mpi:	Makefile jac_mpi.cpp part_util.cpp \
		res.h update.h	\
		$(OP2)/op_datatypes.h $(OP2)/op_mpi_seq.cpp \
		$(OP2)/op_mpi_datatypes.h $(OP2)/op_mpi_seq.h $(OP2)/op_mpi_exchange.cpp\
		$(OP2)/op_mpi_debug.cpp $(OP2)/op_mpi_util.cpp $(OP2)/op_mpi_list.cpp
		$(MPICC) $(CCFLAGS) $(INC) $(OMP) -o jac_mpi jac_mpi.cpp 

#
# cleanup
#

clean:
		rm -f jac_seq jac_op jac_cuda jac_op.o jac_kernels.o jac_mpi jac_mpi.o
