

function op_seq_gen()

%
% this sets the max number of arguments in op_par_loop
%

maxargs = 20;



%
% first the top bit with headers and function prototypes
%

file = strvcat(...',...
'//',...
'// headers',...
'//',...
' ',...
'#include <stdlib.h>',...
'#include <stdio.h>',...
'#include <string.h>',...
'#include <math.h>',...
'#include "op_datatypes.h"',...
' ',...
' ',...
'//',...
'// op routine declarations',...
'//',...
' ',...
'void op_init(int, char **);',...
' ',...
'void op_decl_set(int, op_set &, char const *);',...
' ',...
'void op_decl_ptr(op_set, op_set, int, int *, op_ptr &, char const *);',...
' ',...
'void op_decl_ddat(op_set, int, op_datatype, double *, op_dat &, char const *);',...
' ',...
'void op_decl_fdat(op_set, int, op_datatype, float *, op_dat &, char const *);',...
' ',...
'void op_decl_idat(op_set, int, op_datatype, int *, op_dat &, char const *);',...
' ',...
'void op_decl_dat(op_set s,int d,op_datatype t,double *da,op_dat &dt,char const *nm){',...
'    op_decl_ddat(       s,    d,            t,        da,        dt,            nm);',...
'}',...
' ',...
'void op_decl_dat(op_set s,int d,op_datatype t,float *da,op_dat &dt,char const *nm){',...
'    op_decl_fdat(       s,    d,            t,       da,        dt,            nm);',...
' }',...
' ',...
'void op_decl_dat(op_set s,int d,op_datatype t,int *da,op_dat &dt,char const *nm){',...
'    op_decl_idat(       s,    d,            t,     da,        dt,            nm);',...
'}',...
' ',...
'void op_decl_dconst(int, op_datatype, double *, char const *);',...
' ',...
'void op_decl_fconst(int, op_datatype, float *, char const *);',...
' ',...
'void op_decl_iconst(int, op_datatype, int *, char const *);',...
' ',...
'void op_decl_const(int d,op_datatype t,double *da,char const *nm){',...
'    op_decl_dconst(    d,            t,        da,            nm);',...
'}',...
' ',...
'void op_decl_const(int d,op_datatype t,float *da,char const *nm){',...
'    op_decl_fconst(    d,            t,       da,            nm);',...
' }',...
' ',...
'void op_decl_const(int d,op_datatype t,int *da,char const *nm){',...
'    op_decl_iconst(    d,            t,     da,            nm);',...
'}',...
' ',...
'void op_fetch_data(op_dat);',...
' ',...
'void op_diagnostic_output();',...
' ',' ');

%
% now for op_par_loop defns
%

for nargs = 1:maxargs

  file = strvcat(file, ...
    '// ',...
   ['// op_par_loop routine for ' num2str(nargs) ' arguments '],...
    '// ',' ');

  n_per_line = 5;

  line = 'template < ';
  for n = 1:nargs
    line = [ line 'class T' num2str(n-1) ','];
    if (n==nargs)
      line = [line(1:end-1) ' >'];
    end
    if (mod(n,n_per_line)==0 || n==nargs)
      file = strvcat(file,line);
      line = '           ';
    elseif (n<=10)
      line = [line ' '];
    end
  end

  line = ['void op_par_loop_' num2str(nargs) '(void (*kernel)( '];
  for n = 1:nargs
    line = [ line 'T' num2str(n-1) '*,'];
    if (n==nargs) 
      line = [line(1:end-1) ' ),'];
    end
    if (mod(n,n_per_line)==0 || n==nargs)
      file = strvcat(file,line);
      line = '                                    ';
    elseif (n<=10)
      line = [line ' '];
    end
  end

  file = strvcat(file,'  char const * name, op_set set,');

  for n = 1:nargs
    if (n<=10)
      line = '  op_dat arg0, int idx0, op_ptr ptr0, int dim0, op_datatype typ0, op_access acc0,';
    else
      line = '  op_dat arg0,int idx0,op_ptr ptr0,int dim0,op_datatype typ0,op_access acc0,';
    end
    line = regexprep(line,'0',num2str(n-1));
    if (n==nargs)
      line = [line(1:end-1) '){'];
    end
    file = strvcat(file,line);
  end

  file = strvcat(file,' ',   ['  int           nargs = ' num2str(nargs) ';'], ' ');

  file = add_lines(file,nargs,'  int              idxs','idx');
  file = add_lines(file,nargs,'  int              dims','dim');
  file = add_lines(file,nargs,'  op_datatype      typs','typ');
  file = add_lines(file,nargs,'  op_access        accs','acc');
  file = add_lines(file,nargs,'  int         *ptr_ptrs','ptr.ptr');
  file = add_lines(file,nargs,'  int          ptr_dims','ptr.dim');
  file = add_lines(file,nargs,'  float         *f_dats','arg.fdat');
  file = add_lines(file,nargs,'  double        *d_dats','arg.ddat');
  file = add_lines(file,nargs,'  int           *i_dats','arg.idat');

  file = add_lines(file,nargs,'  int          ptr_from','ptr.from.index');
  file = add_lines(file,nargs,'  int            ptr_to','ptr.to.index');
  file = add_lines(file,nargs,'  int          arg_sets','arg.set.index');
  file = add_lines(file,nargs,'  int          arg_dims','arg.dim');
  file = add_lines(file,nargs,'  op_datatype arg_types','arg.type');

  file = strvcat(file,       ['  float         *f_args[' num2str(nargs) '];']);
  file = strvcat(file,       ['  double        *d_args[' num2str(nargs) '];']);
  file = strvcat(file,       ['  int           *i_args[' num2str(nargs) '];']);
  file = strvcat(file,       ['  void            *args[' num2str(nargs) '];']);


%
% first chunk of plain text
%

  file = strvcat(file,' ',...
'  int n2, ninds=0;',...
' ',...
'  // consistency checks',...
' ',...
'  if (OP_DIAGS>0) {',...
'    for (int m=0; m<nargs; m++) {',...
'      if (idxs[m]>=0) ninds++;',...
' ',...
'      if (idxs[m] == -1) {',...
'        if (ptr_ptrs[m] != NULL) {',...
'          printf("error: wrong pointer for arg %d in kernel \"%s\"\n",m,name);',...
'          exit(1);',...
'        }',...
'      }',...
'      else {',...
'        if (set.index != ptr_from[m] || arg_sets[m] != ptr_to[m]) {',...
'          printf("error: wrong pointer for arg %d in kernel \"%s\"\n",m,name);',...
'          exit(1);',...
'        }',...
'        if (ptr_dims[m] <= idxs[m]) {',...
'          printf(" %d %d",ptr_dims[m],idxs[m]);',...
'          printf("error: invalid pointer index for arg %d in kernel \"%s\"\n",m,name);',...
'          exit(1);',...
'        }',...
'      }',...
'      if (arg_types[m] != typs[m]) {',...
'        printf("error: wrong datatype for arg %d in kernel \"%s\"\n",m,name);',...
'        exit(1);',...
'      }',...
'      if (arg_dims[m] != dims[m]) {',...
'        printf("error: wrong dimension for arg %d in kernel \"%s\"\n",m,name);',...
'        exit(1);',...
'      }',...
'    }',...
'  }',...
' ',...
'  if (OP_DIAGS>1) {',...
'    if (ninds==0)',...
'      printf(" kernel routine w/o indirection:  %s \n",name);',...
'    else',...
'      printf(" kernel routine with indirection: %s \n",name);',...
'  }',...
' ',...
'  // allocate memory for local arrays, and',...
'  // initialise to zero (important for increments)',...
' ',...
'  for (int m=0; m<nargs; m++) {',...
'    if (typs[m] == OP_FLOAT) {',...
'      args[m]   = calloc(dims[m],sizeof(float));',...
'      f_args[m] = (float *) args[m];',...
'    }',...
'    else if (typs[m] == OP_DOUBLE) {',...
'      args[m]   = calloc(dims[m],sizeof(double));',...
'      d_args[m] = (double *) args[m];',...
'    }',...
'    else if (typs[m] == OP_INT) {',...
'      args[m]   = calloc(dims[m],sizeof(int));',...
'      i_args[m] = (int *) args[m];',...
'    }',...
'  }',...
' ',...
'  // loop over set elements',...
' ',...
'  for (int n=0; n<set.size; n++) {',...
'    for (int m=0; m<nargs; m++) {',...
'      if (accs[m]==OP_READ || accs[m]==OP_RW) {',...
'        if (ptr_dims[m]==0)                 // identity mapping',...
'          n2 = n;',...
'        else                                // standard pointers',...
'          n2 = ptr_ptrs[m][idxs[m]+n*ptr_dims[m]];',...
' ',...
'        if (typs[m] == OP_FLOAT)',...
'          for(int p=0; p<dims[m]; p++) f_args[m][p] = f_dats[m][p+n2*dims[m]];',...
'        else if (typs[m] == OP_DOUBLE)',...
'          for(int p=0; p<dims[m]; p++) d_args[m][p] = d_dats[m][p+n2*dims[m]];',...
'        else if (typs[m] == OP_INT)',...
'          for(int p=0; p<dims[m]; p++) i_args[m][p] = i_dats[m][p+n2*dims[m]];',...
'      }',...
'    }',...
' ',...
'    // call kernel function, passing in pointers to data',...
' ');

%
% call to user's kernel
%

  line = ['    kernel( '];
  for n = 1:nargs
    line = [ line '(T' num2str(n-1) '*)args['  num2str(n-1) '],'];
    if (n==nargs) 
      line = [line(1:end-1) ' );'];
    end
    if (mod(n,n_per_line)==0 || n==nargs)
      file = strvcat(file,line);
      line = '            ';
    elseif (n<=10)
      line = [line '  '];
    end
  end

%
% second chunk of plain text
%

  file = strvcat(file,' ',...
'    for (int m=0; m<nargs; m++) {',...
'      if (accs[m]==OP_WRITE || accs[m]==OP_RW) {',...
' ',...
'        if (ptr_dims[m]==0)                 // identity mapping',...
'          n2 = n;',...
'        else                                // standard pointers',...
'          n2 = ptr_ptrs[m][idxs[m]+n*ptr_dims[m]];',...
' ',...
'        if (typs[m] == OP_FLOAT)',...
'          for(int p=0; p<dims[m]; p++) f_dats[m][p+n2*dims[m]] = f_args[m][p];',...
'        else if (typs[m] == OP_DOUBLE)',...
'          for(int p=0; p<dims[m]; p++) d_dats[m][p+n2*dims[m]] = d_args[m][p];',...
'        else if (typs[m] == OP_INT)',...
'          for(int p=0; p<dims[m]; p++) i_dats[m][p+n2*dims[m]] = i_args[m][p];',...
'      }',...
' ',...
'      if (accs[m]==OP_INC) {',...
'        if (ptr_dims[m]==0)                 // identity mapping',...
'          n2 = n;',...
'        else                                // standard pointers',...
'          n2 = ptr_ptrs[m][idxs[m]+n*ptr_dims[m]];',...
' ',...
'        if (typs[m] == OP_FLOAT)',...
'          for(int p=0; p<dims[m]; p++) {',...
'            f_dats[m][p+n2*dims[m]] += f_args[m][p];',...
'            f_args[m][p] = 0.0f;',...
'          }',...
'        else if (typs[m] == OP_DOUBLE)',...
'          for(int p=0; p<dims[m]; p++) {',...
'            d_dats[m][p+n2*dims[m]] += d_args[m][p];',...
'            d_args[m][p] = 0.0;',...
'          }',...
'        else if (typs[m] == OP_INT)',...
'          for(int p=0; p<dims[m]; p++) {',...
'            i_dats[m][p+n2*dims[m]] += i_args[m][p];',...
'            i_args[m][p] = 0;',...
'          }',...
'      }',...
'    }',...
'  }',...
'}');

end


%
% print out into file
%


fid = fopen('op_seq.h','wt');
fprintf(fid,'// \n// auto-generated by op_seq_gen.m on %s \n//\n\n',datestr(now));
for n=1:size(file,1)
  fprintf(fid,'%s\n',file(n,:));
end
fclose(fid);


%
% little function to handle a tricky bit
%

function file = add_lines(file,nargs,str1,str2)

n_per_line = 3;

line = [   str1 '[' num2str(nargs) '] = { '];

for n = 1:nargs
  line = [ line str2(1:3) num2str(n-1) str2(4:end) ','];
  if (n==nargs) 
    line = [line(1:end-1) ' };'];
  end
  if (mod(n,n_per_line)==0 || n==nargs)
    file = strvcat(file,line);
    line = '                                ';
  elseif (n<=10)
    line = [line ' '];
  end
end
